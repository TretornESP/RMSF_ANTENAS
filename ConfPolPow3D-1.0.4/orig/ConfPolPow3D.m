%**************************************************************************
% This file is part of ConfPolPow3D
% 
% ConfPolPow3D is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% ConfPolPow3D is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with ConfPolPow3D.  If not, see <http://www.gnu.org/licenses/>.
%
%**************************************************************************
%
% Created: Aug 1st, 2011
% Last modification: October 15th, 2020.
% Version: 1.0.4
% Code an main idea: J.C. Bregains

% Department of Computer Engineering
% Faculty of Computer Science, A Corunha University, Spain
% Campus de Elvinha, CP 15071, A Corunha, Spain
% Tlf: (+34) 981167000 1209
% Fax: (+34) 981167160
%
% URL: http://gtec.des.udc.es/web/images/files/confpolpow3d.zip
% 
% Copyright 2015 J.C. Bregains
% 
% See README.txt
% 
%**************************************************************************
%**************************************************************************
%**************************************************************************
%**************************************************************************
%  Description
%--------------------------------------------------------------------------
%   ConfPolPow3D.m is a source code with gui prepared to show the positions, 
%   amplitude/phase distributions and the polar power patterns (3D and 2D,
%   specifying total field, and its both theta and phi components) 
%   generated by a conformal antenna.
%   The relative excitation amplitude of each element is plotted 
%   with an orientation along the local Z axis of such an element.
%           
%   The way the program works is explained clearly with plenty of 
%   comments added practically before each line of the source code.
%   Last changes: adaptation to MATLAB R2020a, fixing some issues related
%   to the visualization of a few of the main GUI components. Besides, a
%   20% increment was given to DMax, see (current) line 410.
%**************************************************************************
%**************************************************************************

% --- Executes just before CONFPOLPOW3D is made visible.
function varargout = ConfPolPow3D(varargin)
% CONFPOLPOW3D M-file for CONFPOLPOW3D.fig
%      CONFPOLPOW3D, by itself, creates a new CONFPOLPOW3D or raises the existing
%      singleton*.
%
%      H = CONFPOLPOW3D returns the handle to a new CONFPOLPOW3D or the handle to
%      the existing singleton*.
%
%      CONFPOLPOW3D('CALLBACK',hObject,eventData,handles,...) calls the local
%      function named CALLBACK in CONFPOLPOW3D.M with the given input arguments.
%
%      CONFPOLPOW3D('Property','Value',...) creates a new CONFPOLPOW3D or raises the
%      existing singleton*.  Starting from the left, property value pairs are
%      applied to the GUI before ConfPolPow3D_OpeningFcn gets called.  An
%      unrecognized property name or invalid value makes property application
%      stop.  All inputs are passed to ConfPolPow3D_OpeningFcn via varargin.
%
%      *See GUI Options on GUIDE's Tools menu.  Choose "GUI allows only one
%      instance to run (singleton)".
%
% See also: GUIDE, GUIDATA, GUIHANDLES

% Edit the above text to modify the response to help CONFPOLPOW3D

% Last Modified Byn GUIDE v2.5 25-Jul-2011 17:19:28

% Begin initialization code - DO NOT EDIT
gui_Singleton = 1;
gui_State = struct('gui_Name',       mfilename, ...
                   'gui_Singleton',  gui_Singleton, ...
                   'gui_OpeningFcn', @ConfPolPow3D_OpeningFcn, ...
                   'gui_OutputFcn',  @ConfPolPow3D_OutputFcn, ...
                   'gui_LayoutFcn',  [] , ...
                   'gui_Callback',   []);
if nargin && ischar(varargin{1})
    gui_State.gui_Callback = str2func(varargin{1});
end

if nargout
    [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
else
    gui_mainfcn(gui_State, varargin{:});
end
% End initialization code - DO NOT EDIT

%%

% --- Outputs from this function are returned to the command line.
function ConfPolPow3D_OpeningFcn(hObject, eventdata, handles, varargin)
% --- The following function initializes several variables
% This function has no output args, see OutputFcn.
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% varargin   command line arguments to CONFPOLPOW3D (see VARARGIN)

% Choose default command line output for CONFPOLPOW3D
handles.output = hObject;

% Array configuration stored? Not yet
handles.ConfStored = 0;

% Pattern calculations made? Not yet
handles.Calc3DMade = 0; handles.Calc2DMade = 0;

% Plotted configuration and patterns? Not yet
handles.PlotAmp = 0; handles.PlotPha = 0;
handles.Plot3D = 0; handles.PlotCut = 0;

% Update handles structure
guidata(hObject, handles);

% Clear prompt line
clc;
%%

% UIWAIT makes CONFPOLPOW3D wait for user response (see UIRESUME)
% uiwait(handles.MainForm);

%%

% --- Output function
function varargout = ConfPolPow3D_OutputFcn(hObject, eventdata, handles)
% varargout  cell array for returning output args (see VARARGOUT);
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Get default command line output from handles structure
varargout{1} = handles.output;

%%

% --- Executes during MainForm object creation, after setting all properties. Nothing done.
function MainForm_CreateFcn(hObject, eventdata, handles)
% hObject    handle to MainForm (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

%%

% --- Executes on mouse press over MainForm figure background. Nothing done.
function MainForm_ButtonDownFcn(hObject, eventdata, handles)
% hObject    handle to MainForm (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

%%

% --- Executes when MainForm is resized.
function MainForm_ResizeFcn(hObject, eventdata, handles)
% hObject    handle to MainForm (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Get handlers
handles = guidata(hObject);

% Get the old positions
MainForm = findobj('Tag','MainForm'); PosMainForm = get(MainForm,'Position'); HMainForm = PosMainForm(1,4);
DrawPan = findobj('Tag','Draw_panel'); PosDrawPan  = get(DrawPan,'Position'); WDrawPan = PosDrawPan(1,3); HDrawPan = PosDrawPan(1,4);
PattOptPan = findobj('Tag','PattOpts_panel'); PosPattOptPan = get(PattOptPan,'Position'); HPattOptPan = PosPattOptPan(1,4);
VisSpFr = findobj('Tag','VisualSpace_frame'); PosVisSpFr = get(VisSpFr,'Position'); WVisSpFr = PosVisSpFr(1,3); HVisSpFr = PosVisSpFr(1,4);

% Now calculate the new coordinates and readjust the objects
YDrawPan = HMainForm - (HDrawPan + 0.9); YPatOptPan = HMainForm - (HDrawPan + HPattOptPan + 1.7);
set(DrawPan,'Position',[1 YDrawPan WDrawPan HDrawPan]);
set(PattOptPan,'Position',[1 YPatOptPan WDrawPan HPattOptPan]);
set(VisSpFr,'Position',[WDrawPan + 2 YPatOptPan WVisSpFr HVisSpFr]);

% Update
guidata(hObject,handles);

%%

% --- Executes on pressing AmplDist_chck button. Nothing done.
function AmplDist_chck_Callback(hObject, eventdata, handles)
% hObject    handle to AmplDist_chck (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of AmplDist_chck

%%

% --- Executes on pressing PhaDist_chck button. Nothing done.
function PhaDist_chck_Callback(hObject, eventdata, handles)
% hObject    handle to PhaDist_chck (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of PhaDist_chck

%%

% --- Executes during ConesMaxLength object creation, after setting all properties.
function ConesMaxLength_CreateFcn(hObject, eventdata, handles)
% hObject    handle to ConesMaxLength (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end;

%%

% --- Executes on any event on ConesMaxLength textbox.   
function ConesMaxLength_Callback(hObject, eventdata, handles)
% hObject    handle to ConesMaxLength (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of ConesMaxLength as text
%        str2double(get(hObject,'String')) returns contents of ConesMaxLength as a double

% Get the string from the ConesMaxLength edit text and convert it to a number
CLength = get(handles.ConesMaxLength,'String');
CLength = str2num(CLength);
 
% Verify the user has inserted some positive real number
if (isempty(CLength) || CLength < 0 || isnan(CLength))
    msgbox('Please, insert a positive real number','Wrong input','warn');
    set(handles.ConesMaxLength,'String','0.60');
else
    set(handles.ConesMaxLength,'String', num2str(CLength,'%10.2f'));
end;

guidata(hObject,handles);       % Update data

%% 

 % --- Executes during ConesRadius object creation, after setting all properties.
function ConesRadius_CreateFcn(hObject, eventdata, handles)
% hObject    handle to ConesRadius (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end;

%%

% --- Executes on any event on ConesRadius textbox. 
function ConesRadius_Callback(hObject, eventdata, handles)
% hObject    handle to ConesRadius (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of ConesRadius as text
%        str2double(get(hObject,'String')) returns contents of ConesRadius as a double

% Get the string from the CylRadius edit text and convert it to a number
CRad = get(handles.ConesRadius,'String');
CRad = str2num(CRad);
 
% Verify the user has inserted some positive real number
if (isempty(CRad) || CRad < 0 || isnan(CRad))
    msgbox('Please, insert a positive real number','Wrong input','warn');
    set(handles.ConesRadius,'String','0.25');
else
    set(handles.ConesRadius,'String', num2str(CRad,'%10.2f'));
end;

guidata(hObject,handles);       % Update data

%%

% --- Executes during CylMaxLength object creation, after setting all properties.
function CylMaxLength_CreateFcn(hObject, eventdata, handles)
% hObject    handle to CylMaxLength (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end;

%%

% --- Executes on any event on CylMaxLength textbox. 
function CylMaxLength_Callback(hObject, eventdata, handles)
% hObject    handle to CylMaxLength (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of CylMaxLength as text
%        str2double(get(hObject,'String')) returns contents of CylMaxLength as a double

% Get the string from the ConesMaxLength edit text and convert it to number
CyLength = get(handles.CylMaxLength,'String');
CyLength = str2num(CyLength);
 
% Verify the user has inserted some positive real number
if (isempty(CyLength) || CyLength < 0 || isnan(CyLength))
    msgbox('Please, insert a positive real number','Wrong input','warn');
    set(handles.CylMaxLength,'String','0.80');
else
    set(handles.CylMaxLength,'String', num2str(CyLength,'%10.2f'));
end;
guidata(hObject,handles);       % Update data

%%

% --- Executes during CylRadius object creation, after setting all properties.
function CylRadius_CreateFcn(hObject, eventdata, handles)
% hObject    handle to CylRadius (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end;

%%

% --- Executes on any event on CylRadius textbox. 
function CylRadius_Callback(hObject, eventdata, handles)
% hObject    handle to CylRadius (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of CylRadius as text
%        str2double(get(hObject,'String')) returns contents of CylRadius as a double

% Get the string from the CylRadius edit text and convert it to number
CRad = get(handles.CylRadius,'String');
CRad = str2num(CRad);
 
% Verify the user has inserted some positive real number
if (isempty(CRad) || CRad < 0 || isnan(CRad))
    msgbox('Please, insert a positive real number','Wrong input','warn');
    set(handles.CylRadius,'String','0.25');
else
    set(handles.CylRadius,'String', num2str(CRad,'%10.2f'));
end;

guidata(hObject,handles);       % Update data

%%

% --- Executes on pressing ArrBrowse_button.
% --- The function loads the conformal array configuration, making several initial computations.
function ArrBrowse_button_Callback(hObject, eventdata, handles)
% hObject    handle to ArrBrowse_button (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Get the array configuration from the filename specified by the user,
% specifying a filter on .dat type files
ConfigFile=uigetfile('../*.dat');
% Read the element positions (lambda units), excitations and direction angles 
% Format: 
% X,Y,Z: coordinates of each element center position
% Amp,Phadeg: amplitude and phase (degrees) of elements excitations
% (AXn,BXn,GXn),(AYn,BYn,GYn): alpha, beta and gamma angles of Xn and Yn axes of element n
% KElem: integer that indicates the element factor used by each element (see PolElemF function)
[X,Y,Z,Amp,PhaDeg,AXn,BXn,GXn,AYn,BYn,GYn,KElem]=textread(ConfigFile,'%f %f %f %f %f %f %f %f %f %f %f %d');

% Verify the information given in the file. If it is not correct,
% notify the user and clear the buffer.

if(isempty(KElem))  % If the last column is not there...
    msgbox('Wrong data. Please, check the input file.', 'Wrong input', 'error'); 
    % Configuration stored? Not yet
    handles.ConfStored = 0;
    % Update
    guidata(hObject,handles);
else
    NElem = size(X,1);
    if (NElem < 1),  % If there are no elements...
        messg = sprintf('No elements found.\n Please, check the input file.');
        msgbox(messg, 'Wrong input', 'error');
        % Configuration stored? Not yet
        handles.ConfStored = 0;
        % Update
        guidata(hObject,handles);
    else
        % If everything is OK, then perform the initial computations

        % Specify the most distant element from the center 
        % and, in case of a single element, establish a minimum lenght equal to one lambda).
        % Set DMax 20% higher than the actual maximum
        dist = sqrt(X.*X+Y.*Y+Z.*Z); DMax = 1.2*max(max(dist)); if DMax == 0; DMax = 1; end; 
    
        % Find the maximum excitation amplitude, then normalize Amp 
        AmpMax = max(max(Amp)); Amp = Amp/AmpMax;

        % Transform the phases to radians
        PhaRad = pi*PhaDeg/180;

        % Angles of Xn e Yn to radians:
        AXnRad = AXn.*pi/180; BXnRad = BXn.*pi/180; GXnRad = GXn.*pi/180;  
        AYnRad = AYn.*pi/180; BYnRad = BYn.*pi/180; GYnRad = GYn.*pi/180; 

        % Find the Xn and Yn components in term of the angles, and then concatenate
        % the results in matrices of dimensions NElem x 3
        Xnx = cos(AXnRad); Xny = cos(BXnRad); Xnz = cos(GXnRad);
        Xn = [Xnx  Xny  Xnz];
        Ynx = cos(AYnRad); Yny = cos(BYnRad); Ynz = cos(GYnRad);
        Yn = [Ynx Yny Ynz];

        % Find Zn as the cross product between Xn and Yn:
        Zn = cross(Xn,Yn,2);

        % As the angle between Xn and Yn could not be 90º, normalize Zn and then
        % make sure that Xn and Yn are perpendicular
        Norm_Zn = sqrt(sum(Zn.^2,2));
        Zn = Zn./repmat(Norm_Zn,1,3);
        Yn = cross(Zn, Xn,2);
        
        % Count the kind of elements encountered in the array 
        % (this list must match the elements handled by PolElemF function)
        % Initially, we use NDip (dipoles), NCos2 (cos^2 patches), NIso (isotropic)
        NDip = sum(KElem == 1); NCos2 = sum(KElem == 2); NIso = sum(KElem == 3);

        % Now notify the user that the initial configuration is ready
        if(NElem == 1), 
            MessgA = sprintf('1 element found: \n%d Dipole \n%d Cos^2 patch',NDip, NCos2);
            MessgB = sprintf('\n%d Polarized Omnidir. \nConfiguration ready now.',NIso);
            Messg = strcat(MessgA,MessgB);
        else
            MessgA = strcat(num2str(NElem),sprintf(' elements found: \n%d Dipole(s) \n%d Cos^2 patch(es)', NDip,NCos2));
            MessgB = sprintf('\n%d Polarized Omnidir. \nConfiguration ready now.',NIso);
            Messg = strcat(MessgA,MessgB);            
        end;
        msgbox(Messg,'Array initial structure.','help');
               
        % Store data to be used later
        % Number of elements
        handles.NElem = NElem;
        % Positions
        handles.X = X; handles.Y = Y; handles.Z = Z; handles.R = [X Y Z];
        % Excitations
        handles.Amp = Amp; handles.PhaRad = PhaRad; handles.PhaDeg = PhaDeg; handles.KElem = KElem;
        % Direction cosines (axes projections)
        handles.Xn = Xn; handles.Yn = Yn; handles.Zn = Zn; handles.Rn =[Xn Yn Zn];
        % Maximum distance (to establish the size of the array configuration plots)
        handles.DMax = DMax;
        % Configuration stored? Yes
        handles.ConfStored = 1;
        
        % Update
        guidata(hObject,handles);
        
    end; % End for verifying if there are no elements
end;  % End for verifying the presence of the last column (KElem integer variable)

%%

% --- Executes on pressing DrawArr_button.
% --- To draw array excitation configuration (both amplitude and phase separately).
function DrawArr_button_Callback(hObject, eventdata, handles)
% hObject    handle to DrawArr_button (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Set inicial condition to zero (in principle, draws will not be performed)
DrawCond = 0;

% Now proceed to verify the conditions
% First of all, verify the array has been configured. 
if(handles.ConfStored == 0),     % If the configuration is not ready, notify the user
    Messg = sprintf('Please, click first on \n "Browse..." to load a suitable array configuration');
    msgbox(Messg,'Array not configured yet','warn');
    DrawCond = 0;                   % Conditions are not met                   
elseif(get(handles.AmplDist_chck,'Value')==0 && get(handles.PhaDist_chck,'Value') == 0), % If no options are selected, notify also
    Messg = sprintf('Please, choose "Array Amplitude Distribution" \n and/or "Array Phase Distribution"'); 
    msgbox(Messg,'No array feature selected','warn');
    DrawCond = 0;                   % Conditions are not met
else
    % If the plots actually exist, ask the user if he/she agrees with erasing the previous plots
    if(handles.PlotAmp ==  1 || handles.PlotPha ==  1),
        Messg = sprintf('This will reset previous plots. Agree?');
        DrawQuest = questdlg(Messg,'Ready to erase, and draw again','OK','Cancel','Cancel');
        % If the user agrees: condition are met and therefore reset figures
        if(strcmp(DrawQuest,'OK')), 
            Ampfig = findobj('Tag','ExcitAmplDistr_fig');       % Get amplitudes figure handler
            Phafig = findobj('Tag','ExcitPhaDistr_fig');        % Get phases figure handler
            cla(Ampfig); cla(Phafig);                           % Clear both of them
            guidata(hObject,handles);                           % Update
            DrawCond = 1;                                       % Conditions met    
        else
            DrawCond = 0;                                       % Conditions not met
        end;
    else DrawCond = 1;                                          % If the plots do not exist, condition are met
    end;
end;  % End of configuration verification
            
% Now if the conditions are met, plot the figures
if(DrawCond == 1),
% Load the variables (maximum distance from array center to last element, number of elements,
% direction cosines -local axes projections-, and elements positions)
    DMax = handles.DMax; NElem = handles.NElem;
    Xn = handles.Xn; Yn = handles.Yn; Zn = handles.Zn; R = handles.R;
    PopUp = 0;                                                  % Indicates that the plot is not outside the main form
    TxtSz = 9;                                                  % Small fonts

    % Draw the amplitude distribution if required
    if (get(handles.AmplDist_chck,'Value')==1),
        Amp = handles.Amp;                                          % Retrieve the amplitudes
        AmplAxes = handles.ExcitAmplDistr_fig;                      % Handle the figure
        axes(AmplAxes);                                             % and get its axes
        AmpFact = str2num(get(handles.ConesMaxLength,'String'));    % Get amplitude factor 
        RadFact = str2num(get(handles.ConesRadius,'String'));       % Get radius factor
        set(AmplAxes,'FontSize',TxtSz);                             % Set the size of the font      
        DrawAmplitudes(NElem,R,Xn,Yn,Zn,Amp,DMax,AmpFact,RadFact,TxtSz,PopUp); % Draw the amplitude distribution
        set(handles.ExcitAmplDistr_fig,'Visible','on');             % Be sure the figure is visible
        handles.PlotAmp = 1;                                        % Amplitudes drawn
    end;   

    % Draw the phase distribution if required
    if (get(handles.PhaDist_chck,'Value') == 1),
        PhaDeg = handles.PhaDeg;                                    % Retrieve the amplitudes
        PhaAxes = handles.ExcitPhaDistr_fig;                        % Get the handle of the figure
        axes(PhaAxes);                                              % And set its axes
        PhaFact = str2num(get(handles.CylMaxLength,'String'));      % Get phase factor 
        RadFact = str2num(get(handles.CylRadius,'String'));         % Get radius factor
        set(PhaAxes,'FontSize',TxtSz);                              % Set the size of the font                 
        DrawPhases(NElem,R,Xn,Yn,Zn,PhaDeg,DMax,PhaFact,RadFact,TxtSz,PopUp); % Draw the amplitude distribution
        set(handles.ExcitPhaDistr_fig,'Visible','on');              % Be sure the figure is visible
        handles.PlotPha =  1;                                      % Phases drawn        
    end;

    % Update
    guidata(hObject,handles);
    
end; % End of draw conditions

%%

% --- Executes on pressing ResArr_button.
% --- Resets the array and hides the array visible plots.
function ResArr_button_Callback(hObject, eventdata, handles)
% hObject    handle to ResArr_button (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% First of all, verify that the figures are visible   
if(handles.PlotAmp == 1 || handles.PlotPha == 1), 
    % Ask the user if he wants to proceed
    Messg = sprintf('This will reset the array \n (and hide the array visible plots)');
    CloseQuest = questdlg(Messg,'Warning: reset array configuration','OK','Cancel','Cancel');
    if(strcmp(CloseQuest,'OK')), % If the user agrees, handle the figures, clear and hide them
        Ampfig = handles.ExcitAmplDistr_fig;
        Phafig = handles.ExcitPhaDistr_fig;
        cla(Ampfig); cla(Phafig);
        set(Ampfig,'Visible','off'); set(Phafig,'Visible','off');
        handles.PlotAmp = 0; handles.PlotPha = 0;
        handles.ConfStored = 0;                            % and set: array not stored anymore,
        
        % Update the new ConfStored state
        guidata(hObject,handles);                           
    end;
    
elseif(handles.ConfStored == 1) % If not visible but the array is actually configured
    Messg = sprintf('This will reset the array');
    CloseQuest = questdlg(Messg,'Warning: reset array configuration','OK','Cancel','Cancel');
    if(strcmp(CloseQuest,'OK')), % If the user agrees
        handles.ConfStored = 0;  % "reset" the calculations
        guidata(hObject,handles); % Update the new ConfStored state
    end;
end;  % End of visibility of figures verification

%%

% --- Executes on button press in Total3DPowPat_chck.
% --- Establishes the user whether or not wants to draw 3D power patterns.
function Total3DPowPat_chck_Callback(hObject, eventdata, handles)
% hObject    handle to Total3DPowPat_chck (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of Total3DPowPat_chck
% Get the handler
handles = guidata(hObject);
% If the user does not calculate Total 3D Power Pattern, notify that this could cause normalization inaccuracies 
if(get(findobj('Tag','Total3DPowPat_chck'),'Value') == 0),
    mssg=sprintf('Please, bear in mind that this could affect \n the normalization of the 2D patterns.');
    msgbox(mssg,'Warning','warn');
end;

% Update
guidata(hObject,handles);

%%

% --- Executes on button press in Hemisph_radb.
% --- Establishes the user wants to draw whether over one half or the whole space.
function Hemisph_radb_Callback(hObject, eventdata, handles)
% hObject    handle to Hemisph_radb (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of Hemisph_radb

% Get the handler
handles = guidata(hObject);

% If the user does not calculate Total 3D Power Pattern, notify that this could cause normalization inaccuracies
mssg=sprintf('Please, bear in mind that this could affect \n the normalization of the patterns.');
msgbox(mssg,'Warning','warn');
set(handles.Pat3DAdjust_list,'Enable','off');  % Disable the adjustments list ('Automatic','Packed','Level')

% Update
guidata(hObject,handles);

%% 

% --- Executes on button press in WholeSp_radb.
% --- Establishes the user wants to draw whether over one half or the whole space.
function WholeSp_radb_Callback(hObject, eventdata, handles)
% hObject    handle to WholeSp_radb (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of WholeSp_radb
% Get handlers
handles = guidata(hObject);

% As whole space has been selected by the user, enable 3D patterns adjustments list
set(handles.Pat3DAdjust_list,'Enable','on');

% Update
guidata(hObject,handles);

%%

% --- Executes on button press in TotalCutPatt_chck. Nothing done.
% --- Establishes the user whether or not wants to draw 2D power patterns.
function TotalCutPatt_chck_Callback(hObject, eventdata, handles)
% hObject    handle to TotalCutPatt_chck (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of TotalCutPatt_chck

%%

% --- Executes on button press in Theta_radb. Nothing done.
% --- Establishes the user wants to draw whether a phi-cut or a theta-cut.
function Theta_radb_Callback(hObject, eventdata, handles)
% hObject    handle to Theta_radb (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of Theta_radb

%%

% --- Executes on button press in Phi_radb. Nothing done.
function Phi_radb_Callback(hObject, eventdata, handles)
% hObject    handle to Phi_radb (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of Phi_radb

%%

% --- Executes during Angle_Value object creation, after setting all properties.
function Angle_Value_CreateFcn(hObject, eventdata, handles)
% hObject    handle to Angle_Value (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

%%

% --- Executes on any event on Angle_Value textbox.
% --- In this textbox the user specifies the constant angle to be taken for drawing
% --- a 2D power pattern. This textbox interacts with the Angle_Slider object.
function Angle_Value_Callback(hObject, eventdata, handles)
% hObject    handle to angle_value (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of angle_value as text
%        str2double(get(hObject,'String')) returns contents of angle_value as a double

% Get the string from the Angle_Value edit text and convert it to a number
Angle = get(handles.Angle_Value,'String');
Angle = str2num(Angle);
 
% Verify the user has inserted an angle between 0 and 180
% If not, notify the user and set the value to 90
if (isempty(Angle) || Angle < 0 || isnan(Angle) || Angle > 180)
    msgbox('Please, insert a number between 0 and 180','Wrong input','warn');
    set(handles.Angle_Slider,'Value',90);
    set(handles.Angle_Value,'String','90.00');
else
    set(handles.Angle_Value,'String',num2str(Angle,'%10.2f'));
    set(handles.Angle_Slider,'Value',Angle);
end;

% Update data
guidata(hObject,handles);       

%%

% --- Executes during Angle_Slider object creation, after setting all properties.
function Angle_Slider_CreateFcn(hObject, eventdata, handles)
% hObject    handle to Angle_Slider (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: slider controls usually have a light gray background.
if isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor',[.9 .9 .9]);
end

%%

% --- Executes on slider change.
% --- This textbox interacts with the Angle_Value textbox.
function Angle_Slider_Callback(hObject, eventdata, handles)
% hObject    handle to Angle_Slider (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'Value') returns position of slider
%        get(hObject,'Min') and get(hObject,'Max') to determine range of slider

% Every time the slider value changes, show its value on Angle_Value text
% Get its value
Angle = get(handles.Angle_Slider,'Value');

% and show it on the EditText
set(handles.Angle_Value,'String', num2str(Angle,'%10.2f'));
 
% Update handles structure
guidata(hObject, handles);

%%

% --- Executes during Pat3DAdjust_list object creation, after setting all properties.
function Pat3DAdjust_list_CreateFcn(hObject, eventdata, handles)
% hObject    handle to Pat3DAdjust_list (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: popupmenu controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end;

%%

% --- Executes on selection change in Pat3DAdjust_list. Nothing done.
% --- Establishes the user's needs about the 3D Power Pattern outer box adjustment.
function Pat3DAdjust_list_Callback(hObject, eventdata, handles)
% hObject    handle to Pat3DAdjust_list (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: contents = get(hObject,'String') returns Pat3DAdjust_list contents as cell array
%        contents{get(hObject,'Value')} returns selected item from Pat3DAdjust_list

%% 

% --- Executes on button press in ColorGrad_chck. Nothing done.
% --- Establishes the user whether or not wants to colour the 3D patterns with a level gradient.
function ColorGrad_chck_Callback(hObject, eventdata, handles)
% hObject    handle to ColorGrad_chck (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of ColorGrad_chck

%% 

% --- Executes during LeveldB_Value object creation, after setting all properties.
function LeveldB_Value_CreateFcn(hObject, eventdata, handles)
% hObject    handle to LeveldB_Value (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end;

%%

% --- Executes on any event on LeveldB_Value textbox.
% --- In this textbox the user specifies the minimum level, in dB, given for all the plots.
function LeveldB_Value_Callback(hObject, eventdata, handles)
% hObject    handle to LeveldB_Value (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of LeveldB_Value as text
%        str2double(get(hObject,'String')) returns contents of LeveldB_Value as a double

% Get the string from the LeveldB_Value edit text and convert it to a number
LeveldB = get(handles.LeveldB_Value,'String');
LeveldB = str2num(LeveldB);
 
% Verify the user has inserted a positive real number
if (isempty(LeveldB) || LeveldB < 0 || isnan(LeveldB))
    msgbox('Please, insert a positive real number','Wrong input','warn');
    set(handles.LeveldB_Value,'String','25.00');
else
    set(handles.LeveldB_Value,'String', num2str(LeveldB,'%10.2f'));
end;

% Update data
guidata(hObject,handles);

%%

% --- Executes during NPoints3D_Value object creation, after setting all properties.
function NPoints3D_Value_CreateFcn(hObject, eventdata, handles)
% hObject    handle to NPoints3D_Value (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end;

%%

% --- Executes on any event on NPoints3D_Value textbox.
% --- In this textbox the user specifies the number of theta and phi points to be used for drawing
% --- the 3D Power Pattern.
function NPoints3D_Value_Callback(hObject, eventdata, handles)
% hObject    handle to NPoints3D_Value (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of NPoints3D_Value as text
%        str2double(get(hObject,'String')) returns contents of NPoints3D_Value as a double

% Get the string from the NPoints3D_Value edit text and convert it to a number
N3D_points = get(handles.NPoints3D_Value,'String');
N3D_points = ceil(str2num(N3D_points));
 
% Verify the user has inserted an integer number between 6 and 3000
if (isempty(N3D_points) || N3D_points < 6 || isnan(N3D_points) || N3D_points > 300)
    msgbox('Please, insert an integer between 6 and 300','Wrong input','warn');
    set(handles.NPoints3D_Value,'String','64');
else
    set(handles.NPoints3D_Value,'String', num2str(N3D_points,'%d'));
end;

% Update data
guidata(hObject,handles);

%%

% --- Executes during NPoints2D_Value object creation, after setting all properties.
function NPoints2D_Value_CreateFcn(hObject, eventdata, handles)
% hObject    handle to NPoints2D_Value (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end;

%%

% --- Executes on any event on NPoints2D_Value textbox.
% --- In this textbox the user specifies the number of theta or phi points to be used for drawing
% --- the 2D Power Pattern.
function NPoints2D_Value_Callback(hObject, eventdata, handles)
% hObject    handle to NPoints2D_Value (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of NPoints2D_Value as text
%        str2double(get(hObject,'String')) returns contents of NPoints2D_Value as a double

% Get the string from the NPoints3D_Value edit text and convert it to number
N2D_points = get(handles.NPoints2D_Value,'String');
N2D_points = ceil(str2num(N2D_points));
 
% Verify the user has inserted an integer number between 10 and 1000
if (isempty(N2D_points) || N2D_points < 10 || isnan(N2D_points) || N2D_points > 1000)
    msgbox('Please, insert an integer between 10 and 1000','Wrong input','warn');
    set(handles.NPoints2D_Value,'String','300');
else
    set(handles.NPoints2D_Value,'String', num2str(N2D_points,'%d'));
end;

% Update data
guidata(hObject,handles);

%%

% --- If Enable == 'on', executes on mouse press in 5 pixel border.
% --- Otherwise, executes on mouse press in 5 pixel border or over CalcPattern_button. Nothing done.
function CalcPattern_button_ButtonDownFcn(hObject, eventdata, handles)
% hObject    handle to CalcPattern_button (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

%%

% --- Executes on button press in CalcPattern_button.
% --- Calculates the selected patterns.
function CalcPattern_button_Callback(hObject, eventdata, handles)
% hObject    handle to CalcPattern_button (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Get the handler
handles = guidata(hObject);

if(handles.ConfStored == 0),     % If the configuration is not ready, notify the user
    Messg = sprintf('Please, click first on\n "Browse..." to load a suitable array configuration');
    msgbox(Messg,'Array not configured yet','warn');
    handles.Calc3DMade = 0; handles.Calc2DMade = 0;
else
    % Perform the patterns
    % The maximum level to be represented is taken, in dB, from LeveldB_Value edit text
    LeveldB = ceil(str2double(get(handles.LeveldB_Value,'String')));
    CondLevel = 10^(-LeveldB/20); % To be used for conditional statement for avoiding lower field amplitude values

    % Retrieve the stored values
    NElem = handles.NElem;                                                          % Number of elements
    X = handles.X; Y = handles.Y; Z = handles.Z;                                    % Positions
    Xn = handles.Xn; Yn = handles.Yn; Zn = handles.Zn;                              % Direction cosines (projections) of elements local axes
    Amp = handles.Amp; PhaRad = handles.PhaRad;  KElem = handles.KElem;             % Excitations and kind of element

    % Calculate the inverse transformations of the local coordinates systems
    Sz = size(Zn);   % Size of the direct components matrix
    % Define the inverse components, with the same size as Zn
    XnI = ones(Sz); YnI = XnI; ZnI = XnI;

   % Now build up the inverse component matrices
    for n = 1:NElem, % For each element
        IT_temp = inv([Xn(n,:);Yn(n,:);Zn(n,:)]); % Find the inverse transform (size: 3x3)
        % And set them to the corresponding component matrices
        XnI(n,:) = IT_temp(1,:); YnI(n,:) = IT_temp(2,:); ZnI(n,:) = IT_temp(3,:);
    end;

    %****************************************Start: 3D Pattern calculation**********************************************
    %*******************************************************************************************************************
    %*******************************************************************************************************************

    % Preliminaries for calculating the fields
    % Number of theta and phi points to represent the field are
    % obtained from NPoints3D_Value edit text
    NPTh = ceil(str2double(get(handles.NPoints3D_Value,'String'))); 
    NPPh = NPTh; 

    % Initial and final values of phi (0 to 2pi), and initial theta (to 0)
    ITh = 1e-7; IPh = 0; FPh = 2*pi; % Theta = 0 means Phi = undefined!

    % Specify if the pattern should be plotted over the whole space
    % Remember: Theta = pi means Phi = undefined
     if get(handles.WholeSp_radb,'Value') == 0; FTh = pi/2; else FTh = pi-1e-7; end; 

    % Now calculate the fields
    % Show a progress bar
    WB = waitbar(0,'Calculating 3D fields... please wait...');
    
    % Construct theta and phi matrices, and their sines and cosines
    Theta = linspace(ITh,FTh,NPTh)'; Phi = linspace(IPh,FPh,NPPh);
    IdentTheta = ones(NPTh,1); IdentPhi = ones(1,NPPh);
    SinTheta = sin(Theta); CosTheta = cos(Theta);
    SinPhi = sin(Phi);    CosPhi = cos(Phi);

    % Build up the components of the unitary vectors in spherical coordinates
    ARx = SinTheta*CosPhi; ARy = SinTheta*SinPhi; ARz = CosTheta*IdentPhi;
    ATHx = CosTheta*CosPhi; ATHy = CosTheta*SinPhi; ATHz = -SinTheta*IdentPhi;
    APHx = -IdentTheta*SinPhi; APHy = IdentTheta*CosPhi; APHz = zeros(NPTh,NPPh);

    % Now preallocate the field values matrices (x,y and z components)
    TempFx = zeros(NPTh,NPPh); TempFy = TempFx; TempFz = TempFx;

    % The following lines are performed taking into account matrix operations, which
    % speed the calculations up.
    for n = 1:NElem; % Take a loop on each element
        waitbar(n/NElem);   % Increase the progress bar for each step
        % For each theta and phi points, build an array with the element local axes projections
        Xnx = repmat(Xn(n,1),NPTh,NPPh); Xny = repmat(Xn(n,2),NPTh,NPPh); Xnz = repmat(Xn(n,3),NPTh,NPPh);
        Ynx = repmat(Yn(n,1),NPTh,NPPh); Yny = repmat(Yn(n,2),NPTh,NPPh); Ynz = repmat(Yn(n,3),NPTh,NPPh);
        Znx = repmat(Zn(n,1),NPTh,NPPh); Zny = repmat(Zn(n,2),NPTh,NPPh); Znz = repmat(Zn(n,3),NPTh,NPPh);
        % And the same for the excitations, kind of fields and positions of the elements
        AmpT =repmat(Amp(n),NPTh,NPPh); PhaRadT = repmat(PhaRad(n),NPTh,NPPh); K = repmat(KElem(n),NPTh,NPPh);
        XT = repmat(X(n),NPTh,NPPh); YT = repmat(Y(n),NPTh,NPPh); ZT = repmat(Z(n),NPTh,NPPh);
        % Now find the theta angles in local axes
        Thetan = real(acos(Znx.*ARx + Zny.*ARy + Znz.*ARz));
        % Avoid thetan = 0, which is indeterminate
        Thetan(Thetan == 0) = 1e-7; Thetan(Thetan == pi) = pi-1e-7;
        cos_thn = cos(Thetan); sin_thn = sin(Thetan);
        % Then find the projections for the arhon local unit vector...
        ARhonx = (ARx-Znx.*cos_thn)./sin_thn;
        ARhony = (ARy-Zny.*cos_thn)./sin_thn;
        ARhonz = (ARz-Znz.*cos_thn)./sin_thn;
        % ...which, in conjunction with the inverse transformation matrices...
        XnIx = repmat(XnI(n,1),NPTh,NPPh); YnIx = repmat(YnI(n,1),NPTh,NPPh); ZnIx = repmat(ZnI(n,1),NPTh,NPPh);
        XnIy = repmat(XnI(n,2),NPTh,NPPh); YnIy = repmat(YnI(n,2),NPTh,NPPh); ZnIy = repmat(ZnI(n,2),NPTh,NPPh);
        % ...allow the calculation of the phi angles in local axes
        Phin = real(atan2(XnIy.*ARhonx + YnIy.*ARhony + ZnIy.*ARhonz, XnIx.*ARhonx + YnIx.*ARhony + ZnIx.*ARhonz));
        Phin = bsxfun(@plus, Phin, 2*pi*(Phin<0)); % Be sure that 0 <= Phin < 2*pi    
        
        % Now calculate the element fields components, by applying the PolElemF function
        % in matrix form
        [Felx Fely Felz] = arrayfun(@PolElemF,Thetan,Phin,Xnx,Xny,Xnz,Ynx,Yny,Ynz,Znx,Zny,Znz,K);
        % Then establish the complex coefficient due to amplitudes, phases and positions of the elements
        coeff = AmpT.*exp(i.*(PhaRadT + 2*pi*(ARx.*XT + ARy.*YT + ARz.*ZT)));
        % And finally, set the total field values (x,y and z components)
        TempFx = TempFx + Felx.*coeff; TempFy = TempFy + Fely.*coeff; TempFz = TempFz + Felz.*coeff;           
    end;
    
    % Once the total field has been found, then find the theta, phi and tangential (to a R = constant surface) components
    RTheta = TempFx.*ATHx + TempFy.*ATHy + TempFz.*ATHz; RTheta = arrayfun(@sqrt, RTheta.*conj(RTheta));
    RPhi = TempFx.*APHx + TempFy.*APHy + TempFz.*APHz; RPhi = arrayfun(@sqrt, RPhi.*conj(RPhi));
    RTotal = arrayfun(@sqrt, RTheta.^2 + RPhi.^2);
    
    close(WB);                          % Close progress bar
    
    % Normalize the patterns, finding the maximum first
    MaxRTotal = max(max(RTotal));
    if(MaxRTotal == 0),MaxRTotal = 1; end;
    RTotal = RTotal/MaxRTotal;
    RTheta = RTheta/MaxRTotal;
    RPhi = RPhi/MaxRTotal;
        
    % Now specify the patterns
    % Begin by setting to CondLevel the values that are below the limit that will
    % make 20log10(RTotal(p,q)) to be less than LeveldB, (p and q are any two indexes)
    RTotal(RTotal<CondLevel)=CondLevel;
    % Now set RTotal to dBs without any remorse
    RTotal = 20*log10(RTotal)+LeveldB;

    % Parametrize the points to be used by the corresponding surf() functions
    XXTot = SinTheta*CosPhi.*RTotal;
    YYTot = SinTheta*SinPhi.*RTotal;
    ZZTot = CosTheta*ones(1,NPPh).*RTotal;
        
    % Do the same with the other fields
    RTheta(RTheta<CondLevel) = CondLevel;
    RTheta = 20*log10(RTheta) + LeveldB;
    XXTh = SinTheta*CosPhi.*RTheta;
    YYTh = SinTheta*SinPhi.*RTheta;
    ZZTh = CosTheta*ones(1,NPPh).*RTheta;

    RPhi(RPhi<CondLevel) = CondLevel;
    RPhi = 20*log10(RPhi) + LeveldB;
    XXPh = SinTheta*CosPhi.*RPhi;
    YYPh = SinTheta*SinPhi.*RPhi;
    ZZPh = CosTheta*ones(1,NPPh).*RPhi;
        
    % Store the values to be used later, and update
    handles.XXTot = XXTot; handles.YYTot = YYTot; handles.ZZTot = ZZTot;  handles.RTotal = RTotal; % Total field
    handles.XXTh = XXTh; handles.YYTh = YYTh; handles.ZZTh = ZZTh;  handles.RTheta = RTheta; % Theta component
    handles.XXPh = XXPh; handles.YYPh = YYPh; handles.ZZPh = ZZPh;  handles.RPhi = RPhi; % Phi component

    handles.Calc3DMade = 1;  % For notification that the 3D pattern has been calculated

    % Update
    guidata(hObject,handles);
                 
    %******************************************End: 3D Pattern calculation**********************************************
    %*******************************************************************************************************************
    %*******************************************************************************************************************


    %****************************************Start: Planar Pattern calculation******************************************
    %*******************************************************************************************************************
    %*******************************************************************************************************************
    
    % Preliminary calculations
    AngleCut = str2num(get(handles.Angle_Value,'String'));       % Get cut Angle in degrees
    % Number of Theta or Phi points to represent the field are
    % obtained from NPoints2D_Value edit text
    NPPlanar = ceil(str2double(get(handles.NPoints2D_Value,'String')));
    
    if(get(handles.Phi_radb,'Value') == 1), %If the user has selected a Phi = constant cut
        % Range of Theta and value of Phi
        ITh=1e-7; FTh = 2*pi-1e-7; Phi = AngleCut*pi/180;

        % Construct Theta matrix for a single Phi value
        ThPlanar=linspace(ITh,FTh,NPPlanar)';
        IdTh = ones(NPPlanar,1);
        SinTh = sin(ThPlanar); CosTh = cos(ThPlanar);
        SinPh = sin(Phi); CosPh = cos(Phi);

        % Set the components of the radial unitary vectors in spherical coordinates
        ARx = SinTh*CosPh; ARy = SinTh*SinPh; ARz = CosTh;
        ATHx = CosTh*CosPh; ATHy = CosTh*SinPh; ATHz = -SinTh;
        APHx = -IdTh*SinPh; APHy = IdTh*CosPh; APHz = zeros(NPPlanar,1);
        
        % Initialize temporal field components to zero
        TempFx = zeros(NPPlanar,1); TempFy = TempFx; TempFz = TempFx;
        
        % Now show a progress bar
        WB = waitbar(0,'Calculating pattern cuts... please wait...');
        
        % The following lines are performed taking into account matrix operations, which
        % speed the calculations up.
        for n = 1:NElem;  % Take a loop concerning each element
            waitbar(n/NElem);  % Increase the progress bar for each step
            % For each theta point (phi = constant), build an array with the element local axes projections
            Xnx = repmat(Xn(n,1),NPPlanar,1); Xny = repmat(Xn(n,2),NPPlanar,1); Xnz = repmat(Xn(n,3),NPPlanar,1);
            Ynx = repmat(Yn(n,1),NPPlanar,1); Yny = repmat(Yn(n,2),NPPlanar,1); Ynz = repmat(Yn(n,3),NPPlanar,1);
            Znx = repmat(Zn(n,1),NPPlanar,1); Zny = repmat(Zn(n,2),NPPlanar,1); Znz = repmat(Zn(n,3),NPPlanar,1);
            % And the same for the excitations, kind of fields and positions of the elements
            AmpT =repmat(Amp(n),NPPlanar,1); PhaRadT = repmat(PhaRad(n),NPPlanar,1); K = repmat(KElem(n),NPPlanar,1);
            XT = repmat(X(n),NPPlanar,1); YT = repmat(Y(n),NPPlanar,1); ZT = repmat(Z(n),NPPlanar,1);
            % Now find the theta angles in local axes
            Thetan = real(acos(Znx.*ARx + Zny.*ARy + Znz.*ARz));
            % Avoid thetan = 0, which is indeterminate
            Thetan(Thetan == 0) = 1e-7; Thetan(Thetan == pi) = pi-1e-7;
            cos_thn = cos(Thetan); sin_thn = sin(Thetan);
            % Then find the projections for the arhon local unit vector...
            ARhonx = (ARx-Znx.*cos_thn)./sin_thn;
            ARhony = (ARy-Zny.*cos_thn)./sin_thn;
            ARhonz = (ARz-Znz.*cos_thn)./sin_thn;
            % ...which, in conjunction with the inverse transformation matrices...
            XnIx = repmat(XnI(n,1),NPPlanar,1); YnIx = repmat(YnI(n,1),NPPlanar,1); ZnIx = repmat(ZnI(n,1),NPPlanar,1);
            XnIy = repmat(XnI(n,2),NPPlanar,1); YnIy = repmat(YnI(n,2),NPPlanar,1); ZnIy = repmat(ZnI(n,2),NPPlanar,1);
            % ...allow the calculation of the phi angles in local axes 
            Phin = real(atan2(XnIy.*ARhonx + YnIy.*ARhony + ZnIy.*ARhonz, XnIx.*ARhonx + YnIx.*ARhony + ZnIx.*ARhonz));
            Phin = bsxfun(@plus, Phin, 2*pi*(Phin<0)); % Be sure that 0 <= Phin < 2*pi    
            
            % Now calculate the element fields components, by applying the PolElemF function
            % in matrix form            
            [Felx Fely Felz] = arrayfun(@PolElemF,Thetan,Phin,Xnx,Xny,Xnz,Ynx,Yny,Ynz,Znx,Zny,Znz,K);
            % Then establish the complex coefficient due to amplitudes, phases and positions of the elements
            coeff = AmpT.*exp(i.*(PhaRadT + 2*pi*(ARx.*XT + ARy.*YT + ARz.*ZT)));
            % And finally, set the total field values (x,y and z components)
            TempFx = TempFx + Felx.*coeff; TempFy = TempFy + Fely.*coeff; TempFz = TempFz + Felz.*coeff;           
        end;
        
        % Once the total field has been found, then find the theta, phi and tangential (to a R= constant surface) components
        RThPlanar = TempFx.*ATHx + TempFy.*ATHy + TempFz.*ATHz; RThPlanar = arrayfun(@sqrt, RThPlanar.*conj(RThPlanar));
        RPhPlanar = TempFx.*APHx + TempFy.*APHy + TempFz.*APHz; RPhPlanar = arrayfun(@sqrt, RPhPlanar.*conj(RPhPlanar));
        RTotPlanar = arrayfun(@sqrt, RThPlanar.^2 + RPhPlanar.^2);
        
        close(WB);                          % Close progress bar
        
        % Store theta angles for later use
        handles.AngPlanar = ThPlanar;
        
        % Update
        guidata(hObject);
        
    else % The user has selected a Theta = constant cut
        % Range of Phi and value of Theta
        % avoiding initially problematic values
        if(AngleCut == 0), AngleCut = 1e-7; end;
        if(AngleCut == 180), AngleCut = 180-1e-7; end;
        IPh = 0; FPh = 2*pi; Theta = AngleCut*pi/180;

        % Construct Phi matrix
        PhPlanar = linspace(IPh,FPh,NPPlanar);
        IdPh = ones(1,NPPlanar);
        SinTh = sin(Theta); CosTh = cos(Theta);
        SinPh = sin(PhPlanar); CosPh = cos(PhPlanar);

        % Set the components of the unitary vectors in spherical coordinates
        ARx = SinTh*CosPh; ARy = SinTh*SinPh; ARz = CosTh*IdPh;
        ATHx = CosTh*CosPh; ATHy = CosTh*SinPh; ATHz = -SinTh*IdPh;
        APHx = -SinPh; APHy = CosPh; APHz = zeros(1,NPPlanar);

        % Initialize temporal field components to zero
        TempFx = zeros(1,NPPlanar); TempFy = TempFx; TempFz = TempFx;
        
        % Now show a progress bar
        WB = waitbar(0,'Calculating pattern cuts... please wait...');
        
        % The following lines are performed taking into account matrix operations, which
        % speed the calculations up.
        for n = 1:NElem;   % Take a loop concerning each element
            waitbar(n/NElem);  % Increase the progress bar for each step 
            % For each phi point (theta = constant), build an array with the element local axes projections            
            Xnx = repmat(Xn(n,1),1,NPPlanar); Xny = repmat(Xn(n,2),1,NPPlanar); Xnz = repmat(Xn(n,3),1,NPPlanar);
            Ynx = repmat(Yn(n,1),1,NPPlanar); Yny = repmat(Yn(n,2),1,NPPlanar); Ynz = repmat(Yn(n,3),1,NPPlanar);
            Znx = repmat(Zn(n,1),1,NPPlanar); Zny = repmat(Zn(n,2),1,NPPlanar); Znz = repmat(Zn(n,3),1,NPPlanar);
            % And the same for the excitations, kind of fields and positions of the elements
            AmpT =repmat(Amp(n),1,NPPlanar); PhaRadT = repmat(PhaRad(n),1,NPPlanar); K = repmat(KElem(n),1,NPPlanar);
            XT = repmat(X(n),1,NPPlanar); YT = repmat(Y(n),1,NPPlanar); ZT = repmat(Z(n),1,NPPlanar);
            % Now find the theta angles in local axes
            Thetan = real(acos(Znx.*ARx + Zny.*ARy + Znz.*ARz));
            % Avoid thetan = 0, which is indeterminate
            Thetan(Thetan == 0) = 1e-7; Thetan(Thetan == pi) = pi-1e-7;
            cos_thn = cos(Thetan); sin_thn = sin(Thetan);
            % Then find the projections for the arhon local unit vector...
            ARhonx = (ARx-Znx.*cos_thn)./sin_thn;
            ARhony = (ARy-Zny.*cos_thn)./sin_thn;
            ARhonz = (ARz-Znz.*cos_thn)./sin_thn;
            % ...which, in conjunction with the inverse transformation matrices...
            XnIx = repmat(XnI(n,1),1,NPPlanar); YnIx = repmat(YnI(n,1),1,NPPlanar); ZnIx = repmat(ZnI(n,1),1,NPPlanar);
            XnIy = repmat(XnI(n,2),1,NPPlanar); YnIy = repmat(YnI(n,2),1,NPPlanar); ZnIy = repmat(ZnI(n,2),1,NPPlanar);
            % ...allow the calculation of the phi angles in local axes 
            Phin = real(atan2(XnIy.*ARhonx + YnIy.*ARhony + ZnIy.*ARhonz, XnIx.*ARhonx + YnIx.*ARhony + ZnIx.*ARhonz));
            Phin = bsxfun(@plus, Phin, 2*pi*(Phin<0)); % Be sure that 0 <= Phin < 2*pi    
            
            % Now calculate the element fields components, by applying the PolElemF function
            % in matrix form
            [Felx Fely Felz] = arrayfun(@PolElemF,Thetan,Phin,Xnx,Xny,Xnz,Ynx,Yny,Ynz,Znx,Zny,Znz,K);
            % Then establish the complex coefficient due to amplitudes, phases and positions of the elements
            coeff = AmpT.*exp(i.*(PhaRadT + 2*pi*(ARx.*XT + ARy.*YT + ARz.*ZT)));
            % And finally, set the total field values (x,y and z components)
            TempFx = TempFx + Felx.*coeff; TempFy = TempFy + Fely.*coeff; TempFz = TempFz + Felz.*coeff;           
        end;
        
        % Once the total field has been found, then find the theta, phi and tangential (to a R= constant surface) components
        RThPlanar = TempFx.*ATHx + TempFy.*ATHy + TempFz.*ATHz; RThPlanar = arrayfun(@sqrt, RThPlanar.*conj(RThPlanar));
        RPhPlanar = TempFx.*APHx + TempFy.*APHy + TempFz.*APHz; RPhPlanar = arrayfun(@sqrt, RPhPlanar.*conj(RPhPlanar));
        RTotPlanar = arrayfun(@sqrt, RThPlanar.^2 + RPhPlanar.^2);
        
        close(WB);                          % Close progress bar
        
        % Store phi angles for later use
        handles.AngPlanar = PhPlanar;

        % Update
        guidata(hObject);
    end; % Norm of planar pattern calculated

    % Normalize the patterns with respect to the Maximum
    MaxRPlan = max(max(RTotPlanar));
    if(MaxRPlan < MaxRTotal),
        MaxRPlan = MaxRTotal;
    end;            

    RThPlanar = RThPlanar/MaxRPlan;
    RPhPlanar = RPhPlanar/MaxRPlan;
    RTotPlanar = RTotPlanar/MaxRPlan;

    % Now specify the patterns
    % Begin by setting to CondLevel the values that are below the limit that will
    % make 20log10(RTotPlanar(p)) to be less than LeveldB
    RTotPlanar(RTotPlanar<CondLevel)=CondLevel;
    % Now set RTotal to dBs without remorse
    RTotPlanar=20*log10(RTotPlanar)+LeveldB;
    % Do the same with the other fields
    RThPlanar(RThPlanar<CondLevel)=CondLevel;
    RThPlanar=20*log10(RThPlanar)+LeveldB;
    RPhPlanar(RPhPlanar<CondLevel)=CondLevel;
    RPhPlanar=20*log10(RPhPlanar)+LeveldB;

    % Store the values to be used later
    handles.RTotPlanar = RTotPlanar; handles.RThPlanar = RThPlanar; handles.RPhPlanar = RPhPlanar;
    handles.Calc2DMade = 1;
    
    % Update
    guidata(hObject,handles);

    %****************************************End: Planar Pattern calculation********************************************
    %*******************************************************************************************************************
    %*******************************************************************************************************************
        
    % Notify the user the calculations have been performed
    if(MaxRTotal == 0),
       Messg = sprintf('Null value of total field.\n Please, check the array configuration.\n The drawn patterns will probably be wrong.');
       msgbox(Messg, 'Max norm of field = 0', 'error');
    else
        msgbox('Calculations performed successfully','Work done!','help');
    end;
end;    % End for calculating

%%

% --- Executes on pressing DrawPatt_button.
% --- To draw 2D and/or 3D Power Patterns.
function DrawPatt_button_Callback(hObject, eventdata, handles)
% hObject    handle to DrawPatt_button (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Get the handler
handles=guidata(hObject);

% Set initial condition to zero (in principle, draws will not be performed)
DrawCond = 0;

% Start by verifying that the calculations have been made
if(handles.Calc2DMade == 0 && handles.Calc3DMade == 0),     % If the calculations have not been performed, notify the user
    msgbox('Please, calculate the patterns first','Calculations not performed','warn');
    DrawCond = 0;                                             % Conditions are not met
else
    % If  ready, then ask the user if he/she agrees with erasing the previous plots
    if(strcmp(get(handles.TotalPowPat3D_fig,'Visible'),'on') || strcmp(get(handles.TotalPowPatCut_fig,'Visible'),'on')),
        Messg = sprintf('This will reset previous patterns. Agree?');
        DrawQuest = questdlg(Messg,'Ready to erase, and draw patterns again','OK','Cancel','Cancel');
        % If the user agrees: condition is met and therefore reset figures
        if(strcmp(DrawQuest,'OK')),
            Tridimfig = handles.TotalPowPat3D_fig;
            Twodimfig = handles.TotalPowPatCut_fig;
            cla(Tridimfig); cla(Twodimfig);
            
            % Update data
            guidata(hObject,handles);       
            DrawCond = 1; % Ready to draw
        else
            DrawCond = 0; % Not ready
        end;
    else DrawCond = 1;  % If there are no previous plots, then ready to draw
    end;
end;  % End of verification of previous calculations  
    
% If all is OK, then draw the selected patterns
if(DrawCond == 1),
    % Load the common variables
    LeveldB = ceil(str2double(get(handles.LeveldB_Value,'String')));
    PopUp = 0;                       % Indicates that the plot is not outside the main form
    MainPat = 0;                     % Pattern component to be drawn (0 means Total field)

    % Draw the 3D polar power pattern, if required
    if (get(handles.Total3DPowPat_chck,'Value')==1),                    % If the user has specified the 3D Pattern to be drawn, proceed
        Polar3DPat = handles.TotalPowPat3D_fig;                         % Handle the figure
        axes(Polar3DPat);                                               % and get its axes
        Grad = get(handles.ColorGrad_chck,'Value');                     % See if the user wants the level in color gradient
        if(get(handles.Hemisph_radb,'Value') == 1), AxisFit = 'Half';   % If the user wants the 3D pattern on the hemisphere, set the axes that way
        else
            Val = get(handles.Pat3DAdjust_list,'Value');                % If not 3D pattern on a hemisphere, then set the axes from the list choice
            Str = get(handles.Pat3DAdjust_list, 'String');
            AxisFit = Str{Val};
        end;
        % Now draw the total pattern and store its main axes lengths
        TxtSz = 9;                                  % Small fonts
        Draw3DPow(LeveldB, handles.XXTot, handles.YYTot, handles.ZZTot, handles.RTotal, TxtSz, PopUp, MainPat, Grad, AxisFit); 
        alpha(0.8);                                 % Set the transparency
        set(Polar3DPat,'Visible','on');             % Make the figure visible
        handles.Plot3D = 1;                         % The figure is visible now
        
        % Update
        guidata(hObject,handles);
    end;   

% Draw the planar power pattern, if required
    if (get(handles.TotalCutPatt_chck,'Value')==1),        
        ThC = get(handles.Theta_radb,'Value');                      % See if theta = constant has been chosen
        PlanarPat = handles.TotalPowPatCut_fig;                     % Handle the figure
        axes(PlanarPat);                                            % Asign the axes
        PopUp = 0;                                                  % Draw on the main form (not outside)
        APl = handles.AngPlanar; RadTotPl = handles.RTotPlanar;     % Get angles and pattern values for the plot
        % Now plot the polar figure
        TxtSz = 8;                                                  % Small fonts
        PlanarPlot(APl,RadTotPl,LeveldB,'',TxtSz,PopUp,ThC);        
        set(PlanarPat,'Visible','on');                              % Make the figure visible
        axis off;                                                   % Hide the cartesian axes (it's a polar plot)
        handles.PlotCut = 1;                                        % The pattern has been drawn
        
        % Update
        guidata(hObject,handles);        
    end;
end;    % Draws performed

%%

% --- Executes on pressing ResPowPats_button.
% --- Resets the fields calculations and hides the 2D/3D patterns visible plots.
function ResPowPats_button_Callback(hObject, eventdata, handles)
% hObject    handle to ResPowPats_button (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% Get the handler
handles = guidata(hObject);

% First of all, verify that the figures are visible
if(handles.Plot3D == 1 || handles.PlotCut == 1), 
    % Ask the user if he wants to proceed
    Messg = sprintf('This will reset the calculation \n (and hide the patterns visible plots)');
    CloseQuest = questdlg(Messg,'Warning: reset patterns','OK','Cancel','Cancel');
    if(strcmp(CloseQuest,'OK')), % If the user agrees, get the handlers of the figures and reset them
        Tridimfig = handles.TotalPowPat3D_fig; Twodimfig = handles.TotalPowPatCut_fig;
        cla(Tridimfig); cla(Twodimfig);
        set(Tridimfig,'Visible','off'); set(Twodimfig,'Visible','off');
        handles.Calc2DMade = 0; handles.Calc3DMade = 0;   % Reset calculations
        handles.Plot3D = 0; handles.PlotCut = 0;          % Figures are not visible now
        
        % Update
        guidata(hObject,handles);                           
    end;
elseif(handles.Calc2DMade == 1 || handles.Calc3DMade == 1), % If they are not visible but any of them has been calculated
    Messg = sprintf('This will reset the calculation');
    CloseQuest = questdlg(Messg,'Warning: reset patterns','OK','Cancel','Cancel');
    if(strcmp(CloseQuest,'OK')), % If the user agrees
        handles.Calc2DMade = 0; handles.Calc3DMade = 0; % "Reset" the calculations
        
        % Update
        guidata(hObject,handles); 
    end;    
end;

%%

% --- Executes on pressing PopupAmpl_button.
% --- Creates a separate figure of the amplitude distribution.
function PopupAmpl_button_Callback(hObject, eventdata, handles)
% hObject    handle to PopupAmpl_button (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Create a separate figure, out of the main frame
if (handles.PlotAmp == 1), % If the amplitude plot is visible
    handles = guidata(hObject);                                                 % Get handler
    figure('Name','Excitation Amplitude Distribution','NumberTitle','off');     % Create a new figure
    AmpFact = str2num(get(handles.ConesMaxLength,'String'));                    % Get amplitude factor 
    RadFact = str2num(get(handles.CylRadius,'String'));                         % Get radius factor
    TxtSz = 12; PopUp = 1;                                                      % Small fonts, and Pop up
    
    % Now proceed to draw
    DrawAmplitudes(handles.NElem,handles.R, handles.Xn,handles.Yn,handles.Zn,handles.Amp,handles.DMax,AmpFact,RadFact,TxtSz,PopUp);    
end;

%%

% --- Executes on button press in PopupPha_button.
% --- Creates a separate figure of the phase distribution.
function PopupPha_button_Callback(hObject, eventdata, handles)
% hObject    handle to PopupPha_button (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Create a separate figure, out of the main frame
if (handles.PlotPha == 1), % If the phase plot is visible
    handles = guidata(hObject);                                                 % Get handler
    figure('Name','Excitation Phase Distribution','NumberTitle','off');         % Create a new figure
    PhaFact = str2num(get(handles.CylMaxLength,'String'));                      % Get amplitude factor 
    RadFact = str2num(get(handles.CylRadius,'String'));                         % Get radius factor
    TxtSz = 12; PopUp = 1;                                                      % Small fonts, and Pop up
    
    % Now proceed to draw
    DrawPhases(handles.NElem,handles.R, handles.Xn,handles.Yn,handles.Zn,handles.PhaDeg,handles.DMax,PhaFact,RadFact,TxtSz,PopUp);    
end;

%%

% --- Executes on pressing Popup3D_button.
% --- Creates 3 separate figures of the 3D power patterns (total, theta and phi components).
function Popup3D_button_Callback(hObject, eventdata, handles)
% hObject    handle to Popup3D_button (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Create 3 separate figures, out of the main frame
if(handles.Plot3D == 1), % If the 3D power pattern is visible
    handles = guidata(hObject);                                                     % Get the objects handler
    Grad = get(handles.ColorGrad_chck,'Value');                                     % See if the user wants a level color gradient
    Al = 0.8;                                                                       % Transparency level
    % Total Power Pattern
    TxtSz = 11; PopUp = 1; Pattern = 0;                                             % Font size, Pop up and Total Power Pattern
    figure('Name','3D Polar Total Power Pattern','NumberTitle','off');              % Create a separate figure
    LeveldB = ceil(str2double(get(handles.LeveldB_Value,'String')));                % Get the minimum level in dB
    
    % Now determine the outer box format
    if(get(handles.Hemisph_radb,'Value') == 1), AxisFit = 'Half';       
    else
        Val = get(handles.Pat3DAdjust_list,'Value');
        Str = get(handles.Pat3DAdjust_list, 'String');
        AxisFit = Str{Val};
    end;
    
    % Proceed to draw
    Draw3DPow(LeveldB, handles.XXTot, handles.YYTot, handles.ZZTot, handles.RTotal, TxtSz, PopUp, Pattern, Grad, AxisFit);  
    alpha(Al);                                                                      % Set transparency

    % Theta Component Pattern
    figure('Name','3D Polar Theta-component Power Pattern','NumberTitle','off');    % Create a separate figure
    Pattern = 1;                                                                    % Theta Component
    
    % Proceed to draw
    Draw3DPow(LeveldB, handles.XXTh, handles.YYTh, handles.ZZTh, handles.RTheta, TxtSz, PopUp, Pattern, Grad, AxisFit); 
    alpha(Al);                                                                      % Set transparency
    
    % Phi Component Pattern
    figure('Name','3D Polar Phi-component Power Pattern','NumberTitle','off');      % Create a separate figure
    Pattern = 2;                                                                    % Phi Component
    
    % Proceed to draw and set transparency
    Draw3DPow(LeveldB, handles.XXPh, handles.YYPh, handles.ZZPh, handles.RPhi, TxtSz, PopUp, Pattern, Grad, AxisFit);
    alpha(Al);
end;

%%

% --- Executes on pressing on PowTotalPatCut_frame. Nothing done.
function PowTotalPatCut_frame_ButtonDownFcn(hObject, eventdata, handles)
% hObject    handle to PowTotalPatCut_frame (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

%%

% --- Executes on pressing PopupCut_button.
% --- Creates 3 separate figures of the 2D power patterns (total, theta and phi components).
function PopupCut_button_Callback(hObject, eventdata, handles)
% hObject    handle to PopupCut_button (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Create 3 separate figures, out of the main frame
if (handles.PlotCut == 1), % If the cut is visible
    handles = guidata(hObject);                                                     % Get the objects handler
    ThC = get(handles.Theta_radb,'Value');                                          % See if the user wants a theta cut
    TxtSz = 11; PopUp = 1;                                                          % For a pop-up figure, set font size to 10
    Angle_Cut = get(handles.Angle_Value,'String');                                  % Get the constant angle value from textbox
    LeveldB = ceil(str2double(get(handles.LeveldB_Value,'String')));                % Get the minimum level in dB            
    
    % Total Power Pattern
    figure('Name','2D Polar Total Power Pattern','NumberTitle','off');              % Create a separate figure
    if(ThC == 1),                                                                   % Establish text to be used on figure, according to user cut option
        TtlTot = strcat('Total Field in dB (\theta = ',Angle_Cut,'º Cut)');
        TtlTh = strcat('\theta-Comp. Field in dB (\theta = ',Angle_Cut,'º cut)');
        TtlPh = strcat('\phi-Comp. Field in dB (\theta = ',Angle_Cut,'º Cut)');
    else
        TtlTot = strcat('Total Field in dB (\phi = ',Angle_Cut,'º Cut)');
        TtlTh = strcat('\theta-Comp. Field in dB (\phi = ',Angle_Cut,'º cut)');
        TtlPh = strcat('\phi-Comp. Field in dB (\phi = ',Angle_Cut,'º Cut)');
    end;
    
    % Proceed to plot
    PlanarPlot(handles.AngPlanar,handles.RTotPlanar,LeveldB,TtlTot,TxtSz,PopUp,ThC);
    axis off; 
        
        % Do the same with the other field components
        % Theta component
        figure('Name','2D Polar Theta Component Power Pattern','NumberTitle','off');
        PlanarPlot(handles.AngPlanar,handles.RThPlanar,LeveldB,TtlTh,TxtSz,PopUp,ThC); 
        axis off;
        
        % Phi component
        figure('Name','2D Polar Phi Component Power Pattern','NumberTitle','off');
        PlanarPlot(handles.AngPlanar,handles.RPhPlanar,LeveldB,TtlPh,TxtSz,PopUp,ThC);
        axis off;
end;

%%

% --- Executes when user attempts to close MainForm.
% --- Ask the user if he/she really wants to close it.
function MainForm_CloseRequestFcn(hObject, eventdata, handles)
% hObject    handle to MainForm (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: delete(hObject) closes the figure
% Ask the user if he/she wants to close the main window
CloseQuest = questdlg('Are you sure you want to close?','Warning','OK','Cancel','Cancel');
if(strcmp(CloseQuest,'OK')), delete(hObject); end;

%%

% --- Executes during ExcitAmplDistr_fig object creation, after setting all properties. Nothing done.
function ExcitAmplDistr_fig_CreateFcn(hObject, eventdata, handles)
% hObject    handle to ExcitAmplDistr_fig (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: place code in OpeningFcn to populate ExcitAmplDistr_fig

%%

% --- Executes on mouse press over axes background. Nothing done.
function ExcitAmplDistr_fig_ButtonDownFcn(hObject, eventdata, handles)
% hObject    handle to ExcitAmplDistr_fig (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

%%

% --- Executes on mouse press over axes background. Nothing done.
function ExcitPhaDistr_fig_ButtonDownFcn(hObject, eventdata, handles)
% hObject    handle to ExcitPhaDistr_fig (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

%%
 
% --- Executes on mouse press over axes background. Nothing done.
function TotalPowPat3D_fig_ButtonDownFcn(hObject, eventdata, handles)
% hObject    handle to TotalPowPat3D_fig (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

%%

% --- Executes on mouse press over axes background. Nothing done.
function TotalPowPatCut_fig_ButtonDownFcn(hObject, eventdata, handles)
% hObject    handle to TotalPowPatCut_fig (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

%%

% --- The following function draws the amplitude excitation distribution.
function DrawAmplitudes(NElem,R,Xn,Yn,Zn,Amp,DMax,AmpFact,RadFact,TxtSz,PopUp)
axis([-DMax DMax -DMax DMax -DMax DMax]);                       % Set the maximum values (limits)
PZA = 1.15;                                                     % Proportion of z axis for locating the text

% If the figure corresponds to a separate window, then include a title
if(PopUp == 1)
    text(-DMax,-DMax,PZA*DMax,'Relative Amplitude (Oriented)','FontSize',TxtSz,'Color','black','HorizontalAlignment','center');
end;

% Set the axes labels
xlabel('X/\lambda','FontSize',TxtSz,'position',[0 1.4*DMax -DMax], 'HorizontalAlignment', 'center');
ylabel('Y/\lambda','FontSize',TxtSz,'position',[1.4*DMax 0 -DMax], 'HorizontalAlignment', 'center');
zlabel('Z/\lambda','FontSize',TxtSz,'position',[1.4*DMax -DMax 0], 'HorizontalAlignment', 'center');
% Draw a grid with same proportion on axes, and boxed by a parallelepiped
grid on; axis square; box on;
% Set a light, with plastic-like appearance
camlight; lightangle(135,0); lighting gouraud;
% Perspective view
camproj('perspective'); view(140,50);
% Draw the orientations of Zn axes as cones, their heights being
% proportional to the excitations amplitudes
PlotConesRot(NElem,R,Xn,Yn,Zn,Amp,AmpFact,RadFact,1);
    
%%
    
% --- The following function draws the phase excitation distribution.    
function DrawPhases(NElem,R,Xn,Yn,Zn,PhaDeg,DMax,PhaFact,RadFact,TxtSz,PopUp)
axis([-DMax DMax -DMax DMax -DMax DMax]);                       % Set the maximum values (limits)
PZA = 1.15;                                                     % Proportion of z axis for locating the text
% If the figure corresponds to a separate window, then include a title
if(PopUp == 1)
    text(-DMax,-DMax,PZA*DMax,'Relative Phase (Degrees -Non oriented-)','FontSize',TxtSz,'Color','black','HorizontalAlignment','center');
end;

% Set the axes labels
xlabel('X/\lambda','FontSize',TxtSz,'position',[0 1.4*DMax -DMax], 'HorizontalAlignment', 'center');
ylabel('Y/\lambda','FontSize',TxtSz,'position',[1.4*DMax 0 -DMax], 'HorizontalAlignment', 'center');
zlabel('Z/\lambda','FontSize',TxtSz,'position',[1.4*DMax -DMax 0], 'HorizontalAlignment', 'center');
% Draw a grid with same proportion on axes, and boxed by a parallelepiped
grid on; axis square; box on;
% Set a light, with plastic-like appearance
camlight; lightangle(135,0); lighting gouraud;
% Perspective view
camproj('perspective'); view(140,50);
% Draw the orientations of Zn axes as cones, their heights being
% proportional to the excitations phases (deg)
PlotConesRot(NElem,R,Xn,Yn,Zn,PhaDeg,PhaFact,RadFact,0);
    
    %%

% --- The following function draws the 3D power patterns.     
function Draw3DPow(LeveldB, XX, YY, ZZ, CLvl, TxtSz, PopUp, Pattern, Grad, AxisFit)
% Set common features: line widht and transparency
LW = 1.00; EdgeAl = 0.2;

if(Pattern == 0),       % Total pattern in red, or jet
    % The following are the colors in case the user does not select a gradient
    EdgeCol = [0.8 0 0]; FcClr = [1 0.16 0.16];
    % The following are the gradient colors
    ClrMp = 'jet'; EdgeColGrad = [0.8 0 0];
    Ttl = sprintf('Normalized Power Density (dB)\nTotal Field');    % Title for the total field        
elseif(Pattern == 1),   % Theta component in magenta, or cool (see comments for Pattern == 0)
    EdgeCol = [0.600 0.000 0.200]; FcClr = 'magenta';
    ClrMp = 'cool'; EdgeColGrad = [0.72 0.0 0.72];
    Ttl = sprintf('Normalized Power Density (dB)\nTheta-component Field');
else                    % Phi component in blue or winter (see comments for Pattern == 0) 
    EdgeCol = 'blue'; FcClr = [0.502 0.502 1.000];
    ClrMp = 'winter'; EdgeColGrad = [0.2 0.6 0.4];    
    Ttl = sprintf('Normalized Power Density (dB)\nPhi-component Field');
end;

if(Grad == 0) % If the user does not choose color gradient
    PS = surf(XX,YY,ZZ,'EdgeColor', EdgeCol, 'EdgeAlpha', EdgeAl+0.3, 'LineWidth', LW);
    set(PS,'FaceColor',FcClr);
else
    surf(XX, YY, ZZ, CLvl, 'EdgeColor', EdgeColGrad, 'EdgeAlpha', EdgeAl, 'LineWidth', LW);
    colormap(ClrMp);

    if(PopUp == 1),  % Now consider the case of a separate figure window
        mnCL = min(min(CLvl)); mxCL = max(max(CLvl));       % Minimum and maximum levels for the color bar
        if((mxCL-mnCL)>0.05), % Be sure that there is a small gap between maximum and minimum (i.e., not zero field)
            % Include a color bar for the gradient, and establish its ticks and labels
            cb = colorbar;     
            CbarTick = 0:5:LeveldB;
            if(numel(CbarTick)<3), CbarTick = 0:2:LeveldB; elseif (numel(CbarTick)>15),CbarTick = 0:10:LeveldB; end;
            ntk = numel(CbarTick);
            CbarTl = -fliplr(CbarTick); CbarTl(1,ntk)=0;
            set(cb,'YLimMode','Manual','YLim',[0 LeveldB],'YTickMode','Manual','YTick',CbarTick,'YTickLabel',CbarTl);
        end;        
    end;
end; % End for determining the color of the surface (3D pattern) plots

% Normalize axes
axis normal; axis equal; 

% Select type of adjustment of the outer box
switch AxisFit,
case 'Level',
    axis([-LeveldB LeveldB -LeveldB LeveldB -LeveldB LeveldB]);
case 'Half',
    axis([-LeveldB LeveldB -LeveldB LeveldB 0 LeveldB]);
case 'Packed',
    axis tight;
case 'Automatic',
    axis auto;        
end;

% Now, in case of separate windows, set a title 
if(PopUp == 1),
    tick_pos = (-LeveldB:5:LeveldB); ticks = abs(tick_pos)-LeveldB;
    annotation('textbox',[.05 .85 .25 .1],'LineStyle','none','String',Ttl,'FontSize',TxtSz);
else
    tick_pos = (-LeveldB:10:LeveldB); ticks = abs(tick_pos)-LeveldB;
end;

% Establish X,Y,Z ticks and labels in blue
set(gca,'XTick',tick_pos,'XTickLabel',ticks); 
set(gca,'YTick',tick_pos,'YTickLabel',ticks);
set(gca,'ZTick',tick_pos,'ZTickLabel',ticks);
set(gca,'XColor', 'blue','YColor', 'blue','ZColor', 'blue','FontSize',TxtSz);

% Set some features for the outer box and the 3D surface appereance
box on; camlight; lightangle(135,0); lighting gouraud; %lightangle(0,45)
camproj('perspective'); view(140,50); % view(50,50); % view(45,20);

% Now plot three cones for indicating the coordinate axes directions
% First, establish the location of the origin of coordinates made of cones
axes_pos = [-2*LeveldB/3 -LeveldB/2 0.75*LeveldB];
% Next, establish the direction cosines of each one
xnx = [0 0 -1]; ynx = [0 1 0]; znx = [1 0 0];
xny = [1 0 0]; yny = [0 0 -1]; zny = [0 1 0];
xnz = [1 0 0]; ynz = [0 1 0]; znz = [0 0 1];
% Set X to blue, Y to magenta, Z to green (see PlotConesRot function)
colx = 2; coly = 3; colz = 5;
% Axis length and base radius
axl = LeveldB/4; br = LeveldB/20;
% Finally, plot the cones
PlotConesRot(1,axes_pos,xnx,ynx,znx,1,axl,br,colx);  
PlotConesRot(1,axes_pos,xny,yny,zny,1,axl,br,coly);    
PlotConesRot(1,axes_pos,xnz,ynz,znz,1,axl,br,colz);
    
%%

% --- The following function draws the 2D polar power patterns.
% --- Part of the code has been inspired from the 'polar' MATLAB(R) function.
function PlanarPlot(Theta,Rho,MaxRh,Ttl,TxtSz,PopUp,ThC)
% Start by comparing the maximum value of Rho vector with MaxRh, 
% which is the absolute value of minimum level in dB
MxRh = max(max(Rho)); if(MxRh > MaxRh), MaxRh = MxRh; end;

hold on;    % Grip the figure to draw on it

% Flip the theta vector for correctly representing it on the plot, and find
% the x and y projections of the polar (radius and angle) vectors
ThetaIp2 = flipud(Theta + pi/2);
SinTh = sin(ThetaIp2); CosTh = cos(ThetaIp2);
X = MaxRh*SinTh; Y = MaxRh*CosTh;

fill(X,Y,'white');      % Draw a white circle with black edge

% Now prepare to draw concentric circles
RMin = 0; RMax = MaxRh; RTicks = RMax/5;

% Define a unit circle
Th = 0:pi/50:2*pi; XUnit = cos(Th); YUnit = sin(Th);  
    
% Force points on X/Y axes to lie on them exactly
Inds = 1:(length(Th)-1)/4:length(Th);
XUnit(Inds(2:2:4)) = zeros(2,1);
YUnit(Inds(1:2:5)) = zeros(3,1);

% Labels on a line at 82º
c82 = cos(82*pi/180);
s82 = sin(82*pi/180);
RIncr = (RMax-RMin)/RTicks;
Index = RMax-RIncr;

% Draw concentric circles
for r = RMin+RIncr:RIncr:(RMax-RIncr),
    plot(XUnit*r,YUnit*r,'color',[.75 .75 .75]);
    Lbl = sprintf('%10.f',-Index);
    text(r*c82,r*s82, Lbl,'HorizontalAlignment','Right','VerticalAlignment','Top','FontSize',TxtSz);
    Index = Index-RIncr;
end;
Lbl = '0';
text((r+RIncr)*c82,(r+RIncr)*s82, Lbl,'HorizontalAlignment','Right','VerticalAlignment','Top','FontSize',TxtSz);
    
% Plot spokes at every 30 degrees an annotate them
Th = fliplr(1:12)*pi/6-3*pi/2;
CsTh = cos(Th); SnTh = sin(Th);
Zr = zeros(1,12);
Cs = [Zr; CsTh];
Sn = [Zr; SnTh];
Rt = 1.1*RMax;

% First make a difference between theta cut and phi cut first values
if(ThC == 0), 
    Lbls = linspace(0,330,12); 
    line(MaxRh*Cs(:,1),MaxRh*Sn(:,1),'linestyle',':','color', [.6 .6 .6]);
    strng = strcat(int2str(Lbls(1,1)),'º \rightarrow \theta');
    text(Rt*CsTh(1),Rt*SnTh(1),strng,'HorizontalAlignment','Left','FontSize',TxtSz);
else
    Lbls = linspace(360,30,12); Lbls(1,1) = 0;
    line(MaxRh*Cs(:,1),MaxRh*Sn(:,1),'linestyle',':','color', [.6 .6 .6]);
    strng = strcat('\phi \leftarrow ',int2str(Lbls(1,1)),'º');
    text(Rt*CsTh(1),Rt*SnTh(1),strng,'HorizontalAlignment','Right','FontSize',TxtSz);
end;

% Not plot the remaining ones
for n = 2:12,
    line(MaxRh*Cs(:,n),MaxRh*Sn(:,n),'linestyle',':','color', [.6 .6 .6]);
    strng = strcat(int2str(Lbls(1,n)),'º');
    text(Rt*CsTh(n),Rt*SnTh(n),strng,'HorizontalAlignment','Center','FontSize',TxtSz);
end;

%Insert a title on the top left hand side of the diagram, if required
if(PopUp==1),
   annotation('textbox',[.05 .85 .25 .1],'LineStyle','none','String',Ttl,'FontSize',TxtSz);
end;

% Finally, plot the power pattern cut
X = Rho.*CosTh; Y = Rho.*SinTh;
plot(X,Y);

% Adjust the axes, and hold off the figure
axis equal; hold off;

%%

% --- The following function plots parametric cones.
function PlotConesRot(Nel,Posn,Xn,Yn,Zn,H,Af,Rf,Ty)
hold on;                                % Grip the figure to draw on it
t = 0:1/14:1;                           % Parametric variable vector t
Th = 2*pi*t;                            % Parametric Angle
CosTh = cos(Th); SinTh=sin(Th);         % Proyections on X and Y axes
Sz = size(t,2);                         % Vector t size    
RCone = Rf*(1-t);                       % Variable radius of cones
Ident = ones(1,Sz);                     % Identity vector
RIdent = Rf*Ident;

if(Ty == 0), % Type (cylinder equal to zero, or cone)
    % Plot cylinders in green
    gr = [0.023 0.235 0.169];           % Dark green color
    Hang = H/360;                       % Normalize the phases distribution
    for ne = 1:Nel, % Go through all the elements
        % Non oriented semi-transparent cylinders 
        Xpc = RIdent'*SinTh+Posn(ne,1);Ypc = RIdent'*CosTh+Posn(ne,2);Zpc = Af*Hang(ne,1)*t'*Ident+Posn(ne,3);
        PS = surf(Xpc,Ypc,Zpc,'EdgeColor', gr, 'EdgeAlpha', 0.20, 'LineWidth', 0.50);
        set(PS,'FaceColor',[0.502 1.000 0.502]); alpha(0.80);
    end;
else
    switch Ty,                          % Several colors for plotting the cones
        case 1, col = 'red'; matcol = [1.000 0.502 0.502];
        case 2, col = 'blue'; matcol = [0.502 0.502 1.000];
        case 3, col = 'magenta'; matcol = [0.800 0.000 0.400];
        case 4, col = 'yellow'; matcol = [1.000 0.800 0.000];
        otherwise, col = 'green'; matcol = [0.502 1.000 0.502]; % Any other except 0
    end;

    % Plot oriented semi-transparent cones
    for ne = 1:Nel, % Go through all the elements
        Xpc = RCone'*(CosTh*Xn(ne,1)+SinTh*Yn(ne,1))+Af*H(ne,1)*t'*Ident*Zn(ne,1)+Posn(ne,1);
        Ypc = RCone'*(CosTh*Xn(ne,2)+SinTh*Yn(ne,2))+Af*H(ne,1)*t'*Ident*Zn(ne,2)+Posn(ne,2);
        Zpc = RCone'*(CosTh*Xn(ne,3)+SinTh*Yn(ne,3))+Af*H(ne,1)*t'*Ident*Zn(ne,3)+Posn(ne,3);
        PS = surf(Xpc,Ypc,Zpc,'EdgeColor', col, 'EdgeAlpha', 0.40, 'LineWidth', 0.50);
        set(PS,'FaceColor',matcol); alpha(0.75);
    end;
end;

%%

% --- The following function corresponds to the polarized element factor, 
% --- which that calculates the field radiated by each element of the array.
function [Felx Fely Felz] = PolElemF(Thetan,Phin,CosAnx,CosBnx,CosGnx,CosAny,CosBny,CosGny,CosAnz,CosBnz,CosGnz,KElem)
% Arguments:
% Thetan, Phin: angles measured on n-th element local coordinate system
% CosAnx, CosBnx, CosGnx: direction cosines of AXn unitary vector
% CosAny, ... ,CosGnz: direction cosines of AYn and azn
% KElem: an integer that indicates which element factor must be chosen
% KElem = 1 means short dipole aligned along z axis
if KElem == 1,
    Den = sin(Thetan);  % To avoid division by zero
    if(Den == 0) Felx = 0; Fely = 0; Felz = 0; 
    else
        BetaHalfLength = pi*0.5; % A half wavelength dipole
        % Now return the element factor projected along zn axis
        Fel = (-(cos(BetaHalfLength.*cos(Thetan))-cos(BetaHalfLength))./Den)*[CosAnz CosBnz CosGnz];
        Felx = Fel(1,1); Fely = Fel(1,2); Felz = Fel(1,3);
    end;
%     % If you want a ground plane parallel to y = 0, uncomment the lines below:
%      SPhn = sin(Phin);        
%      if (SPhn < 0), Felx = 0; Fely = 0; Felz = 0; % Just radiate on 0<=Phi<=pi zone
%      else
%         H = 0.25;                              % Distance from dipole to groundplane
%         Coeff = sin(2*pi*H*sin(Thetan)*SPhn);  % Coeff due to the presence of the groundplane 
%         Felx = Felx*Coeff; Fely = Fely*Coeff; Felz = Felz*Coeff;
%      end;

     % If you want a ground plane parallel to x = 0, uncomment the lines below:
     CPhn = cos(Phin);
     if (CPhn < 0), Felx = 0; Fely = 0; Felz = 0;  % Just radiate on -pi/2<=Phi<=pi/2 zone
     else
       H = 0.25;                         % Distance from dipole to groundplane
       Coeff = sin(2*pi*H*Den*CPhn);     % Coeff due to the presence of the groundplane
       Felx = Felx*Coeff; Fely = Fely*Coeff; Felz = Felz*Coeff;
     end;
             
     % Cos^2 pattern polarized along Thetan axis
 elseif KElem == 2,
     CThn = cos(Thetan);
     if(CThn >= 0)
        % Notice that the field is cos^2(theta) times a_sub_theta times the direction cosines matrix:
        fR = CThn^2*[CThn.*cos(Phin) CThn.*sin(Phin) -sin(Thetan)]*[CosAnx CosBnx CosGnx; CosAny CosBny CosGny; CosAnz CosBnz CosGnz];
        % You can polarize it along Phin axis if you want (must uncomment following line)
        % fR = CThn^2*[-sin(Phin) cos(Phin) 0]*[CosAnx CosBnx CosGnx; CosAny CosBny CosGny; CosAnz CosBnz CosGnz];
        Felx = fR(1,1); Fely = fR(1,2); Felz = fR(1,3);            
     else
        Felx = 0; Fely = 0; Felz = 0;
     end;

    % Omnidirectional field polarized along Thetan or Phin axes:    
 else
    % Along Thetan 
    % CThn = cos(Thetan);
    % fR = [CThn.*cos(Phin) CThn.*sin(Phin) -sin(Thetan)]*[CosAnx CosBnx CosGnx; CosAny CosBny CosGny; CosAnz CosBnz CosGnz];
    % Along Phin
    fR = [-sin(Phin) cos(Phin) 0]*[CosAnx CosBnx CosGnx; CosAny CosBny CosGny; CosAnz CosBnz CosGnz];        
    Felx = fR(1,1); Fely = fR(1,2); Felz = fR(1,3);     
 end;
 
 %%


% --- Executes on key press with focus on CalcPattern_button and none of its controls.
function CalcPattern_button_KeyPressFcn(hObject, eventdata, handles)
% hObject    handle to CalcPattern_button (see GCBO)
% eventdata  structure with the following fields (see UICONTROL)
%	Key: name of the key that was pressed, in lower case
%	Character: character interpretation of the key(s) that was pressed
%	Modifier: name(s) of the modifier key(s) (i.e., control, shift) pressed
% handles    structure with handles and user data (see GUIDATA)


% --- Executes on key press with focus on DrawArr_button and none of its controls.
function DrawArr_button_KeyPressFcn(hObject, eventdata, handles)
% hObject    handle to DrawArr_button (see GCBO)
% eventdata  structure with the following fields (see UICONTROL)
%	Key: name of the key that was pressed, in lower case
%	Character: character interpretation of the key(s) that was pressed
%	Modifier: name(s) of the modifier key(s) (i.e., control, shift) pressed
% handles    structure with handles and user data (see GUIDATA)
